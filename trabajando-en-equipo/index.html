<!DOCTYPE html>

<!--
  Google HTML5 slide template

  Authors: Luke Mahé (code)
           Marcin Wichary (code and design)
           
           Dominic Mazzoni (browser compatibility)
           Charles Chen (ChromeVox support)

  URL: http://code.google.com/p/html5slides/
-->

<html>
  <head>
    <title>Git puesto en práctica: Trabajando en equipo</title>
    <meta charset='utf-8'>
    <script src='../js/slides.js'></script>
  </head>
  
  <body style='display: none'>

    <section class='slides layout-regular template-default'>
      
      <!-- Your slides (<article>s) go here. Delete or comment out the
           slides below. -->
        
        
      <a class="home" href=".."><img src="../images/home-icon2.png" /></a>

      <article class='biglogo'>
        <h1 class="title">Git puesto en práctica</h1>
        <h2 class="title">Git</h2>
        <h3 class="subtitle">Trabajando en equipo</h3>
        <div class="subinfo">
          Apreta la tecla <span class="key">&rarr;</span> para avanzar.
        </div>
        <div class='source'>
          <a href="https://plus.google.com/100184619238119414805/posts">+David Rubert</a>
        </div>
      </article>

      <article>
        <h1 class="title">
          Introducción
        </h1>
        <hr class="title" />
        <h2>Progamación en equipo</h2>
        <p class="justify">
          La programación en equipo de proyectos hoy en día es fundamental, y los beneficios
          son múltiples tanto para los desarrolladores como para el proyecto.
          Si vamos a trabajar en un proyecto en equipo con <strong>git</strong>
          deberemos saber:
        </p>
        <ul>
            <li>Realizar <strong>commits</strong> "documentados" al repositorio.</p>
            <li>Trabajar con <strong>ramas</strong>.</li>
            <li>Subir/descargar cambios de repositorios padre.</li>
            <li>Saber lo que es el <strong>3-way merge</strong>.</li>
        </ul>
      </article>

      <article>
        <h1 class="title">Commits documentados</h1>
        <hr class="title" />
        <img class="logo" src="images/rocket.jpg" />
        <p class="justify">
        Cada <strong>commit</strong> al repositorio debe estar bien
        documentado, es una recomendación de buenas prácticas de desarrollo a
        la que si nos acostumbramos ayudaremos mucho a la evolución de los
        proyectos en los que participemos.
        </p>
        <hr />
        <p>Los <strong>commits</strong> que realizamos en principio se
        almacenan únicamente en nuestro repositorio, pero trabajando en equipo
        lo normal es mandarlos a un repositorio padre en el que participan varias
        personas.</p>
      </article>
      
      <article>
        <h2>Commit roñoso</h2>
        <img class="logo" src="images/error.jpg" />
        <p class="justify">
        Veamos un ejemplo de un <strong>commit</strong> mal documentado. Puede
        que nuestras modificaciones sean perfectas, pero el comentario asociado
        al <strong>commit</strong> debe acompañarlas. Ejemplo:</p>
        <img style="width: 780px; margin-top: .5em;" src="images/badcommit.png" />
      </article>
      
      <article>
        <h2>Commit con sustancia</h2>
        <img class="logo" src="images/thumbsup.png" />
        <p class="justify">
        Veamos un ejemplo de un <strong>commit</strong> bien documentado. La
        primera línea debe ser un resumen de todos los cambios. En las líneas
        siguientes podemos explicarlo con detalle, separando los párrafos
        adecuadamente.</p>
        <img style="width: 780px; margin-top: .5em;" src="images/goodcommit.png" />
      </article>
     
      <article>
        <h1 class="title">git log</h1>
        <hr class="title" />
        <img class="logo" src="images/log.png" />
        <p class="justify">
        Necesitamos una herramienta con la que poder examinar cuáles han sido
        los últimos <strong>commits</strong> al repositorio. Al trabajar en
        equipo los cambios que hacen los compañeros pueden afectar a nuestro
        desarrollo. <strong>git log</strong> es la utilidad que necesitamos
        para ello.
        </p>
        <hr />
        <p>Veamos algunos ejemplos, aunque <strong>git log</strong> es muy
        potente y nos permite parametrizar la consulta en función de lo que
        queramos obtener, el uso más común es el que vamos a ver en las
        próximas pantallas.
        </p>
      </article>
      
      <article>
        <h1 class="title">git log --oneline</h1>
        <hr class="title" />
        <p>Si ejecutamos este comando dentro de un directorio de trabajo
        veremos un resumen de los últimos commits al repositorio. Muy útil para
        echar un vistazo rápido a las últimas modificaciones.</p>
        <iframe style="position: normal; height: 350px; width: 780px;
        margin-top: 1em;" src="gitlogoneline.txt">
        </iframe>
      </article>
 
      <article>
        <h1 class="title">git log</h1>
        <hr class="title" />
        <p>Veamos el resultado de ejecutar un <strong>git log</strong> sin
        parámetros dentro de un directorio de trabajo clonado del propio
        repositorio del código fuente de <strong>git</strong>.</p>
        <iframe style="position: normal; height: 400px; width: 780px;
        margin-top: 1em;" src="gitlog.html">
        </iframe>
      </article>
 
      <article>
        <h1 class="title">git log --oneline --graph --decorate</h1>
        <hr class="title" />
        <p>Podemos navegar con este comando un proyecto tan complejo como git y
        ver cómo desarrollan los gurús.</p>
        <img class="shadow" style="width: 780px; margin-top: 1em;" src="images/gitloggraph.png" />
      </article>
 
      <article class='fill'>
        <h3></h3>
        <img alt="Atención: necesito vuestra concentración 5 minutos" src='../images/attention.gif'>
      </article>
 
      <article>
        <h1 class="title">Trabajando con ramas</h1>
        <hr class="title" />
        <img class="logo" src="images/branch.png" />
        <p class="justify">
        Las ramas son bifurcaciones del proyecto, que permiten desarrollar
        diferentes partes de un software en paralelo. Facilitan el aislar los
        cambios sin afectar al resto del desarrollo, para posteriormente
        fusionar la rama con la <strong>master branch</strong> (si así lo deseamos).
        </p>
        <hr />
        <p>Una rama nueva se crea con <strong>git branch &lt;nombre&gt;</strong>, cambiaremos al contexto de una rama con el comando <strong>git checkout &lt;nombre&gt;</strong>, y fusionaremos ramas con <strong>git merge</strong>. Veamos en detalle cada comando.</p>
      </article>
      
      <article>
        <h1 class="title">git branch</h1>
        <hr class="title" />
        <p class="justify">
        Para listar las ramas creadas en el repositorio:
        </p>
        <pre class="prettify lang-sh">[~/git-puesto-en-practica]$ git branch
* master</pre>
        <p>La rama principal que siempre tendremos creada se denomina
        <strong>master</strong>.</p>
        <hr />
        <p>Creamos una rama nueva con el siguiente comando:</p>
        <pre class="prettify lang-sh">[~/git-puesto-en-practica]$ git branch testing
[~/git-puesto-en-practica]$ git branch
* master
  testing</pre>

      </article>
      
      <article>
        <p class="justify">
        Finalmente, borramos una rama utilizando el parámetro
        <strong>-d</strong>.
        </p>
        <pre class="prettify lang-sh">[~/git-puesto-en-practica]$ git branch
* master
  testing
[~/git-puesto-en-practica]$ git branch -d testing
[~/git-puesto-en-practica]$ git branch
* master</pre>
       <hr />
       <p>La facilidad de uso de las ramas nos permite bifurcar una versión
       concreta del proyecto para empezar a trabajar en una nueva
       característica, o un bug que haya que solucionar.</p>
      </article>
      
      <article>
        <h1 class="title">git checkout &lt;branch&gt;</h1>
        <hr class="title" />
        <p class="justify">
        Podemos cambiar el contexto y comenzar a trabajar con otra rama
        mediante el comando <strong>checkout</strong>.
        </p>
        <pre class="prettify lang-sh">[~/git-puesto-en-practica]$ git branch
* master
  devel

[~/git-puesto-en-practica]$ ls
a.txt

[~/git-puesto-en-practica]$ git checkout devel
Switched to branch 'devel'

[~/git-puesto-en-practica]$ git branch
  master
* devel

[~/git-puesto-en-practica]$ ls
a.txt  b.txt
</pre>
      </article>
      
      <article>
        <h1 class="title">git merge &lt;branch&gt;</h1>
        <hr class="title" />
        <p class="justify">
        Si queremos fusionar una rama con la que actualmente estamos
        trabajando, utilizaremos <strong>git merge</strong>:
        </p>
        <pre class="prettify lang-sh">[~/git-puesto-en-practica]$ git branch
* master
  devel
[~/git-puesto-en-practica]$ git merge devel
Updating 211141d..26b8cd6
Fast-forward
 b.txt |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
 create mode 100644 b.txt
</pre>
      <p><strong>Git</strong> es capaz de resolver conflictos en los cambios de
      manera automática (y muy inteligentemente), salvo aquellos que no haya
      más remedio que resolverlos a mano.</p>
      </article>
      
      <article>
        <h1 class="title">Trabajando con repositorios remotos</h1>
        <hr class="title" />
        <img class="logo shadow" src="images/remote.jpg" />
        <p class="justify">
        Un proyecto <strong>git</strong> no tiene un repositorio central al que
        enviar los cambios, pero para colaborar en un proyecto integrado por
        varios desarrolladores, necesitaremos enviar nuestros cambios a un
        repositorio común.</p>
        </p>
        <hr />
        <p class="justify">Es habitual tener definido un repositorio remoto con
        el cual interactuaremos enviando nuestros cambios (si tenemos permisos
        de escritura), o del cual nos traeremos las actualizaciones que se
        vayan produciendo.</p>
      </article>

      <article>
        <p class="justify">
        Los repositorios <strong>git</strong> son todos iguales (no hay
        diferencia entre cliente y servidor). En algunos tendremos permisos de
        lectura y en otros permisos de lectura/escritura.
        </p>
        <p>Podemos definirnos todos los repositorios remotos que queramos
        asociados a nuestro repositorio, de los que obtendremos (y tal vez
        enviemos) actualizaciones.</p>
        <hr />
        <p>El comando que nos permite gestionar los repositorios remotos es
        <strong>git remote</strong>.</p>
      </article>

      <article>
        <h1 class="title">git remote</h1>
        <hr class="title" />
        <img class="logo shadow" src="images/distributed.jpg" />
        <p class="justify">
        Si hemos clonado (con <strong>git clone</strong>) nuestro proyecto, ya
        tendremos definido un repositorio remoto, que por defecto se identifica
        con el alias <strong>origin</strong>.
        <p>
        <p>El comando <strong>git remote -v</strong> nos mostrará todos los
        repositorios remotos que tengamos definidos:</p>
        <pre class="prettify lang-sh">[~/git-puesto-en-practica]$ git remote -v
origin  git@github.com:tombatossals/git-puesto-en-practica.git (fetch)
origin  git@github.com:tombatossals/git-puesto-en-practica.git (push)</pre>
      </article>

      <article>
        <h1 class="title">git remote add/rm</h1>
        <hr class="title" />
        <p class="justify">
        Añadimos o eliminamos repositorios remotos con estos dos comandos. El
        nombre (alias) que le damos al repositorio es a nuestro gusto, aunque
        como convenio se pone el repositorio base como <strong>origin</strong>.
        </p>
        <p>Añadir un repositorio:</p>
        <pre class="prettify lang-sh">git remote add octopress git://github.com/imathis/octopress.git</pre>
        <p>Borrar un repositorio:</p>
        <pre class="prettify lang-sh">git remote rm octopress</pre>
      </article>

      <article class='fill'>
        <h3></h3>
        <img alt="¡No os durmáis todavía! Viene algo interesante." src='images/wait.jpg'>
      </article>

      <article>
        <h1 class="title">Recibir/enviar cambios a los repositorios</h1>
        <hr class="title" />
        <img class="logo" src="images/rocket.jpg" />
        <p class="justify">
        Ya sabemos cómo enlazar nuestro repositorio con otros repositorios
        asociados. Veamos cómo obtener (o enviar) los cambios de un repositorio de nivel
        superior.
        </p>
        <p>Esta operación es muy útil para estar siempre en sincronía 
        con los cambios que van realizando en el proyecto principal.</p>
        <hr />
        <ul>
            <li><strong>git pull</strong>. Obtiene todos
            los últimos cambios del repositorio y hace un
            <strong>merge</strong>.</li>
            <li><strong>git push</strong>. Envía nuestros últimos commits al
            repositorio.</li>
        </ul>
      </article>

      <article>
        <h1 class="title">git pull [&lt;repositorio&gt;]</h1>
        <hr class="title" />
        <img class="logo" src="images/pull.jpg" />
        <p class="justify">
        Este comando obtiene los últimos cambios del repositorio
        remoto, y realiza un <strong>merge</strong> con la rama local con la que estemos
        trabajando.
        </p>
        <pre style="margin-top: .3em;" class="prettify lang-sh">[~/git-puesto-en-practica]$ git pull
remote: Counting objects: 10, done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 6 (delta 3), reused 6 (delta 3)
Unpacking objects: 100% (6/6), done.
From github.com:tombatossals/git-puesto-en-practica
   7d8ccd7..9c0a361  master     -> origin/master
Updating 7d8ccd7..9c0a361
Fast-forward
 acerca-de/index.html                 |   52 ++++++++++++++++++++++++++
 trabajando-en-equipo/images/pull.jpg |  Bin 0 -> 65507 bytes
 trabajando-en-equipo/index.html      |   66 +++++++++++++++++++++++++++++++--
 3 files changed, 114 insertions(+), 4 deletions(-)
 create mode 100644 acerca-de/index.html
 create mode 100644 trabajando-en-equipo/images/pull.jpg</pre>
      </article>

      <article>
        <h1 class="title">git fetch [&lt;repositorio&gt;]</h1>
        <hr class="title" />
        <p class="justify">
        Tal vez <strong>pull</strong> sea un comando "demasiado automático". <strong>git fetch</strong> es una alternativa más controlada, ya que al traerse los cambios del repositorio remoto no los aplica directamente sobre nuestra rama, sino que espera que nosotros lo hagamos manualmente.
        </p>
        <p>Despues de un <strong>git fetch</strong> es conveniente hacer un <strong>git diff upstream/master</strong>, comparando las ramas de trabajo local con la del repositorio remoto.</p>
        <p>Finalmente, si estamos de acuerdo con los cambios, ejecutaremos un <strong>git merge upstream/master</strong>.</p>
      </article>

      <article>
        <h1 class="title">git push [&lt;repositorio&gt;]</h1>
        <hr class="title" />
        <img class="logo" src="images/push.jpg" />
        <p class="justify">
        Enviamos todos los cambios que hemos realizados sobre nuestro
        repositorio local al repositorio/s remoto/s que tengamos definido/s.
        </p>
        <pre class="prettify lang-sh">[~/git-puesto-en-practica]$ git push
Counting objects: 10, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (6/6), done.
Writing objects: 100% (6/6), 60.16 KiB, done.
Total 6 (delta 3), reused 0 (delta 0)
To git@github.com:tombatossals/git-puesto-en-practica.git
   7d8ccd7..9c0a361  master -> master</pre>
      </article>

      <article class='fill'>
        <h3></h3>
        <img alt="Flujo de información en Git (simplificado)" src='images/dataflow.png'>
      </article>

    </section>
      
  </body>
</html>
